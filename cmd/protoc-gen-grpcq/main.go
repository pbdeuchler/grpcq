// Package main implements the protoc-gen-grpcq plugin.
// This plugin generates grpcq service stubs for Protocol Buffer services.
//
// Usage:
//   protoc --grpcq_out=. --grpcq_opt=paths=source_relative your.proto
package main

import (
	"flag"

	"google.golang.org/protobuf/compiler/protogen"
)

var (
	requireUnimplemented = flag.Bool("require_unimplemented_servers", true, "set to false to match legacy behavior")
)

func main() {
	var flags flag.FlagSet
	flags.BoolVar(requireUnimplemented, "require_unimplemented_servers", true,
		"set to false to match legacy behavior")

	protogen.Options{
		ParamFunc: flags.Set,
	}.Run(func(gen *protogen.Plugin) error {
		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}
			generateFile(gen, f)
		}
		return nil
	})
}

func generateFile(gen *protogen.Plugin, file *protogen.File) {
	if len(file.Services) == 0 {
		return
	}

	filename := file.GeneratedFilenamePrefix + "_grpcq.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)

	generateFileHeader(g, file)
	generateFileContent(g, file)
}

func generateFileHeader(g *protogen.GeneratedFile, file *protogen.File) {
	g.P("// Code generated by protoc-gen-grpcq. DO NOT EDIT.")
	g.P("// versions:")
	g.P("// - protoc-gen-grpcq v0.1.0")
	g.P("// source: ", file.Desc.Path())
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()
}

func generateFileContent(g *protogen.GeneratedFile, file *protogen.File) {
	// Import required packages
	g.P("import (")
	g.P("	", g.QualifiedGoIdent(protogen.GoIdent{GoName: "context", GoImportPath: "context"}))
	g.P("	", g.QualifiedGoIdent(protogen.GoIdent{GoName: "grpcq", GoImportPath: "github.com/pbdeuchler/grpcq/go/grpcq"}))
	g.P(")")
	g.P()

	// Generate code for each service
	for _, service := range file.Services {
		generateService(g, file, service)
	}
}

func generateService(g *protogen.GeneratedFile, file *protogen.File, service *protogen.Service) {
	serviceName := service.GoName

	// Generate server interface
	generateServerInterface(g, service, serviceName)
	g.P()

	// Generate server registration
	generateServerRegistration(g, service, serviceName)
	g.P()

	// Generate client interface
	generateClientInterface(g, service, serviceName)
	g.P()

	// Generate client implementation
	generateClientImpl(g, service, serviceName)
	g.P()
}

func generateServerInterface(g *protogen.GeneratedFile, service *protogen.Service, serviceName string) {
	g.P("// ", serviceName, "QServer is the server API for ", serviceName, " service with grpcq.")
	g.P("// This interface is compatible with the gRPC ", serviceName, "Server interface.")
	g.P("// Implementations should embed the gRPC Unimplemented server for compatibility.")
	g.P("type ", serviceName, "QServer interface {")
	for _, method := range service.Methods {
		g.P("	", method.GoName, "(", g.QualifiedGoIdent(protogen.GoIdent{GoName: "Context", GoImportPath: "context"}), ", *", method.Input.GoIdent, ") (*", method.Output.GoIdent, ", error)")
	}
	g.P("}")
}

func generateServerRegistration(g *protogen.GeneratedFile, service *protogen.Service, serviceName string) {
	g.P("// Register", serviceName, "QServer registers the ", serviceName, " server implementation")
	g.P("// with the provided queue adapter and configuration.")
	g.P("func Register", serviceName, "QServer(adapter ", g.QualifiedGoIdent(protogen.GoIdent{GoName: "QueueAdapter", GoImportPath: "github.com/pbdeuchler/grpcq/go/grpcq"}), ", srv ", serviceName, "QServer, opts ...", g.QualifiedGoIdent(protogen.GoIdent{GoName: "ServerOption", GoImportPath: "github.com/pbdeuchler/grpcq/go/grpcq"}), ") *", g.QualifiedGoIdent(protogen.GoIdent{GoName: "Server", GoImportPath: "github.com/pbdeuchler/grpcq/go/grpcq"}), " {")
	g.P("	cfg := &", g.QualifiedGoIdent(protogen.GoIdent{GoName: "ServerConfig", GoImportPath: "github.com/pbdeuchler/grpcq/go/grpcq"}), "{}")
	g.P("	for _, opt := range opts {")
	g.P("		opt(cfg)")
	g.P("	}")
	g.P()
	g.P("	s := ", g.QualifiedGoIdent(protogen.GoIdent{GoName: "NewServer", GoImportPath: "github.com/pbdeuchler/grpcq/go/grpcq"}), "(adapter, cfg)")
	g.P()

	// Register each method
	for _, method := range service.Methods {
		fullServiceName := string(service.Desc.FullName())
		g.P("	s.RegisterMethod(\"", fullServiceName, "\", \"", method.Desc.Name(), "\", func(ctx ", g.QualifiedGoIdent(protogen.GoIdent{GoName: "Context", GoImportPath: "context"}), ", req interface{}) (interface{}, error) {")
		g.P("		return srv.", method.GoName, "(ctx, req.(*", method.Input.GoIdent, "))")
		g.P("	}, func() interface{} { return &", method.Input.GoIdent, "{} })")
	}
	g.P()
	g.P("	return s")
	g.P("}")
}

func generateClientInterface(g *protogen.GeneratedFile, service *protogen.Service, serviceName string) {
	g.P("// ", serviceName, "QClient is the client API for ", serviceName, " service with grpcq.")
	g.P("type ", serviceName, "QClient interface {")
	for _, method := range service.Methods {
		g.P("	", method.GoName, "(ctx ", g.QualifiedGoIdent(protogen.GoIdent{GoName: "Context", GoImportPath: "context"}), ", in *", method.Input.GoIdent, ", opts ...", g.QualifiedGoIdent(protogen.GoIdent{GoName: "CallOption", GoImportPath: "github.com/pbdeuchler/grpcq/go/grpcq"}), ") (*", method.Output.GoIdent, ", error)")
	}
	g.P("}")
}

func generateClientImpl(g *protogen.GeneratedFile, service *protogen.Service, serviceName string) {
	clientStructName := unexport(serviceName) + "QClient"
	fullServiceName := string(service.Desc.FullName())

	g.P("type ", clientStructName, " struct {")
	g.P("	cc *", g.QualifiedGoIdent(protogen.GoIdent{GoName: "Client", GoImportPath: "github.com/pbdeuchler/grpcq/go/grpcq"}))
	g.P("}")
	g.P()

	g.P("// New", serviceName, "QClient creates a new ", serviceName, " client for grpcq.")
	g.P("func New", serviceName, "QClient(adapter ", g.QualifiedGoIdent(protogen.GoIdent{GoName: "QueueAdapter", GoImportPath: "github.com/pbdeuchler/grpcq/go/grpcq"}), ", opts ...", g.QualifiedGoIdent(protogen.GoIdent{GoName: "ClientOption", GoImportPath: "github.com/pbdeuchler/grpcq/go/grpcq"}), ") ", serviceName, "QClient {")
	g.P("	return &", clientStructName, "{")
	g.P("		cc: ", g.QualifiedGoIdent(protogen.GoIdent{GoName: "NewClient", GoImportPath: "github.com/pbdeuchler/grpcq/go/grpcq"}), "(adapter, opts...),")
	g.P("	}")
	g.P("}")
	g.P()

	// Generate method implementations
	for _, method := range service.Methods {
		g.P("func (c *", clientStructName, ") ", method.GoName, "(ctx ", g.QualifiedGoIdent(protogen.GoIdent{GoName: "Context", GoImportPath: "context"}), ", in *", method.Input.GoIdent, ", opts ...", g.QualifiedGoIdent(protogen.GoIdent{GoName: "CallOption", GoImportPath: "github.com/pbdeuchler/grpcq/go/grpcq"}), ") (*", method.Output.GoIdent, ", error) {")
		g.P("	out := new(", method.Output.GoIdent, ")")
		g.P("	err := c.cc.Invoke(ctx, \"", fullServiceName, "\", \"", method.Desc.Name(), "\", in, out, opts...)")
		g.P("	if err != nil {")
		g.P("		return nil, err")
		g.P("	}")
		g.P("	return out, nil")
		g.P("}")
		g.P()
	}
}

// unexport converts a string to unexported (lowercase first letter)
func unexport(s string) string {
	if s == "" {
		return ""
	}
	return string(s[0]+('a'-'A')) + s[1:]
}
